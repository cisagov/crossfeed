import { Cpe, Cve } from '../models';
import axios from 'axios';
import saveCpesToDb from './helpers/saveCpesToDb';
import saveCvesToDb from './helpers/saveCvesToDb';
import { plainToClass } from 'class-transformer';

interface CpeProduct {
  cpe_product_name: string;
  version_number: string;
  vender: string;
}
interface CveEntry {
  cve_uid?: string | null;
  cve_name: string | null;
  published_date?: string | null;
  last_modified_date?: string | null;
  vuln_status?: string | null;
  description?: string | null;
  cvss_v2_source?: string | null;
  cvss_v2_type?: string | null;
  cvss_v2_version?: string | null;
  cvss_v2_vector_string?: string | null;
  cvss_v2_base_score?: number | null;
  cvss_v2_base_severity?: string | null;
  cvss_v2_exploitability_score?: number | null;
  cvss_v2_impact_score?: number | null;
  cvss_v3_source?: string | null;
  cvss_v3_type?: string | null;
  cvss_v3_version?: string | null;
  cvss_v3_vector_string?: string | null;
  cvss_v3_base_score?: number | null;
  cvss_v3_base_severity?: string | null;
  cvss_v3_exploitability_score?: number | null;
  cvss_v3_impact_score?: number | null;
  cvss_v4_source?: string | null;
  cvss_v4_type?: string | null;
  cvss_v4_version?: string | null;
  cvss_v4_vector_string?: string | null;
  cvss_v4_base_score?: number | null;
  cvss_v4_base_severity?: string | null;
  cvss_v4_exploitability_score?: number | null;
  cvss_v4_impact_score?: number | null;
  weaknesses: string[];
  reference_urls: string[];
  vender_product: { [key: string]: CpeProduct[] };
}
interface CvssEndpointResponse {
  task_id: string;
  status: string;
  result?: {
    total_pages: number;
    current_page: number;
    data: CveEntry[];
  };
  error?: string;
}

const fetchCveData = async (page: number) => {
  console.log('Creating task to fetch CVE data');
  try {
    const response = await axios({
      url: 'https://api.staging-cd.crossfeed.cyber.dhs.gov/pe/apiv1/cves_by_modified_date',
      method: 'POST',
      headers: {
        Authorization: String(process.env.CF_API_KEY),
        access_token: String(process.env.PE_API_KEY),
        'Content-Type': '' //this is needed or else it breaks because axios defaults to application/json
      },
      data: {
        page: page,
        per_page: 100 // Tested with 150 and 200 but this results in 502 errors on certain pages with a lot of CPEs
      }
    });
    if (response.status >= 200 && response.status < 300) {
      //console.log('Request was successful');
    } else {
      console.log('Request failed');
    }
    return response.data as CvssEndpointResponse;
  } catch (error) {
    console.log(`Error making POST request: ${error}`);
  }
};
const fetchCveDataTask = async (task_id: string) => {
  console.log('Fetching CVE data');
  try {
    const response = await axios({
      url: `https://api.staging-cd.crossfeed.cyber.dhs.gov/pe/apiv1/cves_by_modified_date/task/${task_id}`,
      headers: {
        Authorization: String(process.env.CF_API_KEY),
        access_token: String(process.env.PE_API_KEY),
        'Content-Type': ''
      }
    });
    if (response.status >= 200 && response.status < 300) {
      //console.log('Request was successful');
    } else {
      console.log('Request failed');
    }
    return response.data as CvssEndpointResponse;
  } catch (error) {
    console.log(`Error making POST request: ${error}`);
  }
};
//notes: add limit to number of times to retry
async function main() {
  let done = false;
  let page = 1;
  let total_pages = 2;

  while (!done) {
    let taskRequest = await fetchCveData(page);
    console.log(`Fetching page ${page} of page ${total_pages}`);
    await new Promise((r) => setTimeout(r, 1000));
    if (taskRequest?.status == 'Processing') {
      while (taskRequest?.status == 'Processing') {
        //console.log('Waiting for task to complete');
        await new Promise((r) => setTimeout(r, 1000));
        taskRequest = await fetchCveDataTask(taskRequest.task_id);
        //console.log(taskRequest?.status);
      }
      if (taskRequest?.status == 'Completed') {
        console.log(`Task completed successfully for page: ${page}`);

        const cveArray = taskRequest?.result?.data || []; //TODO, change this to CveEntry[]
        await saveToDb(cveArray);
        total_pages = taskRequest?.result?.total_pages || 1;
        const current_page = taskRequest?.result?.current_page || 1;
        if (current_page >= total_pages) {
          done = true;
          console.log(`Finished fetching CVE data`);
        }
        page = page + 1;
      }
    } else {
      done = true;
      console.log(
        `Error fetching CVE data: ${taskRequest?.error} and status: ${taskRequest?.status}`
      );
    }
  }
}
export const handler = async (CommandOptions) => {
  await main();
};

export const saveToDb = async (cveArray: CveEntry[]) => {
  for (const cve of cveArray) {
    const cpeArray: Cpe[] = [];
    for (const vender in cve.vender_product) {
      for (const product of cve.vender_product[vender] as CpeProduct[]) {
        cpeArray.push(
          plainToClass(Cpe, {
            name: product.cpe_product_name,
            version: product.version_number,
            vendor: product.vender,
            lastSeenAt: new Date(Date.now())
          })
        );
      }
    }
    const ids: string[] = await saveCpesToDb(cpeArray);
    //SAVE CVE TO DATABASE
    await saveCvesToDb(
      plainToClass(Cve, {
        name: cve.cve_name,
        publishedAt: new Date(cve.published_date!),
        modifiedAt: new Date(cve.last_modified_date!),
        status: cve.vuln_status,
        description: cve.description,
        cvssV2Source: cve.cvss_v2_source,
        cvssV2Type: cve.cvss_v2_type,
        cvssV2Version: cve.cvss_v2_version,
        cvssV2VectorString: cve.cvss_v2_vector_string,
        cvssV2BaseScore: cve.cvss_v2_base_score,
        cvssV2BaseSeverity: cve.cvss_v2_base_severity,
        cvssV2ExploitabilityScore: cve.cvss_v2_exploitability_score,
        cvssV2ImpactScore: cve.cvss_v2_impact_score,
        cvssV3Source: cve.cvss_v3_source,
        cvssV3Type: cve.cvss_v3_type,
        cvssV3Version: cve.cvss_v3_version,
        cvssV3VectorString: cve.cvss_v3_vector_string,
        cvssV3BaseScore: cve.cvss_v3_base_score,
        cvssV3BaseSeverity: cve.cvss_v3_base_severity,
        cvssV3ExploitabilityScore: cve.cvss_v3_exploitability_score,
        cvssV3ImpactScore: cve.cvss_v3_impact_score,
        cvssV4Source: cve.cvss_v4_source,
        cvssV4Type: cve.cvss_v4_type,
        cvssV4Version: cve.cvss_v4_version,
        cvssV4VectorString: cve.cvss_v4_vector_string,
        cvssV4BaseScore: cve.cvss_v4_base_score,
        cvssV4BaseSeverity: cve.cvss_v4_base_severity,
        cvssV4ExploitabilityScore: cve.cvss_v4_exploitability_score,
        cvssV4ImpactScore: cve.cvss_v4_impact_score,
        weaknesses: cve.weaknesses,
        references: cve.reference_urls
      }),
      ids
    );
  }
};
