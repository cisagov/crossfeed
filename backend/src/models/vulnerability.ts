import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  BaseEntity,
  CreateDateColumn,
  ManyToOne,
  Index,
  UpdateDateColumn,
  BeforeInsert,
  BeforeUpdate
} from 'typeorm';
import { User } from './user';
import { Domain } from './domain';
import { Service } from './service';
import { IsBoolean, IsOptional } from 'class-validator';

export type VulnerabilitySubstate =
  | 'unconfirmed'
  | 'exploitable'
  | 'false-positive'
  | 'accepted-risk'
  | 'remediated';

@Entity()
@Index(['domain', 'title'], { unique: true })
@Index(['createdAt'])
@Index(['updatedAt'])
export class Vulnerability extends BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne((type) => Domain, (domain) => domain.vulnerabilities, {
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE'
  })
  domain: Domain;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @Column({ nullable: true, type: 'timestamp' })
  lastSeen: Date | null;

  @Column()
  title: string;

  @Column({
    nullable: true,
    type: 'text'
  })
  cve: string | null;

  @Column({
    nullable: true,
    type: 'text'
  })
  cwe: string | null;

  @Column({
    nullable: true,
    type: 'text'
  })
  cpe: string | null;

  @Column({
    default: ''
  })
  description: string;

  @Column({
    type: 'jsonb',
    default: []
  })
  references: {
    url: string;
    name: string;
    source: string;
    tags: string[];
  }[];

  @Column({
    nullable: true,
    type: 'decimal'
  })
  cvss: number | null;

  @Column({
    nullable: true,
    type: 'text'
  })
  severity: 'None' | 'Low' | 'Medium' | 'High' | 'Critical' | null;

  @Column({
    default: false
  })
  needsPopulation: boolean;

  @Column({ default: 'open' })
  state: 'open' | 'closed';

  @Column({ default: 'unconfirmed' })
  substate: VulnerabilitySubstate;

  /** Determines the source of the vulnerability, i.e., which
   * logic caused it to be created.
   */
  @Column({ default: 'cpe2cve' })
  source:
    | 'cpe2cve'
    | 'webpage_status_code'
    | 'certs'
    | 'shodan'
    | 'hibp'
    | 'lookingGlass'
    | 'dnstwist'
    | 'rootDomainSync';

  @Column({
    default: ''
  })
  notes: string;

  @ManyToOne((type) => Service, {
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE'
  })
  service: Service;

  @Column({
    type: 'jsonb',
    default: []
  })
  actions: {
    type: 'state-change' | 'comment';
    state?: string;
    substate?: string;
    value?: string;
    automatic: boolean;
    userId: string | null;
    userName: string | null;
    date: Date;
  }[];

  /** Stores structured vulnerability data related to a specific
   * scan type, e.g., a list of emails found in breaches for a domain.
   */
  @Column({
    type: 'jsonb',
    default: {}
  })
  structuredData: object;

  setState(
    substate: VulnerabilitySubstate,
    automatic: boolean,
    user: User | null
  ) {
    this.substate = substate;
    if (substate === 'unconfirmed' || substate === 'exploitable')
      this.state = 'open';
    else this.state = 'closed';
    this.actions.unshift({
      type: 'state-change',
      state: this.state,
      substate: this.substate,
      automatic,
      userId: user ? user.id : null,
      userName: user ? user.fullName : null,
      date: new Date()
    });
  }

  /** Set to true if the vulnerability has been on the CISA Known Exploited Vulnerability (KEV) list. **/
  @IsBoolean()
  @IsOptional()
  @Column({
    default: false,
    nullable: true
  })
  isKev?: boolean;

  /* KEV results */
  @IsOptional()
  @Column({
    type: 'jsonb',
    default: {},
    nullable: true
  })
  kevResults?: {
    [x: string]: any;
  };

  @BeforeInsert()
  @BeforeUpdate()
  setSeverity() {
    if (!this.cvss) return;
    if (this.cvss === 0) this.severity = 'None';
    else if (this.cvss < 4) this.severity = 'Low';
    else if (this.cvss < 7) this.severity = 'Medium';
    else if (this.cvss < 9) this.severity = 'High';
    else this.severity = 'Critical';
  }
}
